# Widgets：向主窗口添加新元素
## a basic tab
import部分：
```
import {
    Widget
} from '@phosphor/widgets';
```
于是可以在Widget的基础上，自定义一个小部件。
使用app.shell可以将这个小部件添加到主区域（main area）。  
**? const { commands, shell } = app这句什么意思**  
！解构。  
```
    activate: (
        app: JupyterLab,
        palette: ICommandPalette,
        mainMenu: IMainMenu) =>
    {
        const { commands, shell } = app;
        let command = 'ex3:labtutorial';
        let category = 'Tutorial';
        commands.addCommand(command, {
            label: 'Ex3 command',
            caption: 'Open the Labtutorial',
            execute: (args) => {
                const widget = new TutorialView();
                shell.addToMainArea(widget);}});
        palette.addItem({command, category});

        let tutorialMenu: Menu = new Menu({commands});

        tutorialMenu.title.label = 'Tutorial';
        mainMenu.addMenu(tutorialMenu, {rank: 80});
        tutorialMenu.addItem({ command });
    }
```
在以上代码中，commands:app.command使用addCommand方法将command与一系列动作以及属性绑定起来，加入到命令注册表（ICommandRegistry）中；palette：ICommandPalette使用addItem方法将命令command加入到命令面板的category分类中。tutorialMenu: Menu使用addItem方法将command添加为一个新的菜单项对应的动作，而mainMenu: IMainMenu使用addMenu方法将tutorialMenu: Menu这个菜单添加到菜单栏中。  
（？上面这一段还需要再理一遍，感觉逻辑不够清晰）  
接下来看看command这个命令对应的操作：widget部件为TutorialView()类的一个实例，app.shell提供addToMainArea()方法将其这个部件加入到主区域中去。
TutorialView部件是对Widget基类的扩展，如下：
```
class TutorialView extends Widget {
    constructor() {
        super();
        this.addClass('jp-tutorial-view')
        this.id = 'tutorial'
        this.title.label = 'Tutorial View'
        this.title.closable = true;
    }
}
```
其中使用了定制的css类（jp-tutorial-view），它在style/index.css文件中定义的。
启动之后在命令面板中选择对应的命令，在主视图中应该可以看到新的标签页。  

## Datagrid
接下来尝试插入一个phosphor example到JypyterLab上。
导入部分：
```
import {
    Panel
} from '@phosphor/widgets';

import {
  DataGrid, DataModel
} from '@phosphor/datagrid';
```
其中，Panel部件可以通过.addWidget方法添加几个子部件。DataGrid部件用于显示数据。DataModel为DataGrid提供数据。
接下来对TutorialView进行如下修改：
```
class TutorialView extends Panel {
    constructor() {
        super();
        this.addClass('jp-tutorial-view')
        this.id = 'tutorial'
        this.title.label = 'Tutorial View'
        this.title.closable = true;

        let model = new LargeDataModel();
        let grid = new DataGrid();
        grid.model = model;

        this.addWidget(grid);
    }
}
```
在上述代码中，使用.addWidget()方法向TutorialView视图中添加了一个grid部件，而grid是DataGrid的一个实例，其.model属性赋值为model——也就是一个LargeDataModel类的实例。
接下来看看LargeDataModel是如何定义的：
```
class LargeDataModel extends DataModel {

  rowCount(region: DataModel.RowRegion): number {
    return region === 'body' ? 1000000000000 : 2;
  }

  columnCount(region: DataModel.ColumnRegion): number {
    return region === 'body' ? 1000000000000 : 3;
  }
    data(region: DataModel.CellRegion, row: number, column: number): any {
    if (region === 'row-header') {
        return `R: ${row}, ${column}`;
    }
    if (region === 'column-header') {
        return `C: ${row}, ${column}`;
    }
    if (region === 'corner-header') {
        return `N: ${row}, ${column}`;
    }
    return `(${row}, ${column})`;
    }
}
```
它继承了DataModel基类。  
其中，rowCount()的输入参数region: DataModel.RowRegion在 phosphor.js中的定义如下：  
```
export
type RowRegion = 'body' | 'column-header';

/**
 * A type alias for the data model column regions.
 */
export
type ColumnRegion = 'body' | 'row-header';

/**
 * A type alias for the data model cell regions.
 */
export
type CellRegion = 'body' | 'row-header' | 'column-header' | 'corner-header';
```  
可以看出，RowRegion可以是body(表格体)或者是column-header。
所以rowCount()和columnCount()分别定义了2个列索引，1000000000000 行和3个行索引，1000000000000 列。


