# 周汇报2-22

## TODO

- [x] authenticate流程整理
- [x] LocalAuthenticator
- [x] 代理相关知识
- [x] spawn
- [x] db(可以先看pam的)
- [ ] 属性里面的tag（）



## 文档输出

### authenticator流程

LoginHandler处理流程

**GET**

1.收到get请求之后，**首先检查当前用户是否为空**，不为空则直接设置login_cookie,并重定向至get_next_url对应的地址,否则进行身份验证, 执行2.

2.若authenticator.auto_login == true(这个值是可配置的),意味着身份验证器需要启动一个除了/hub/login之外的另一个验证过程(自定义的)，此时将会使用authenticator.login_url()方法获得需要重定向到的那个页面的url。

3.若self.auto_login==self.settings['login_url'],即步骤2.所得到的url就是login_url，则4;否则5.

![user不为空](D:\2020_Sources\2020秋\实习\截图\2-22\user不为空.png)

4.等待self.login_user执行并返回, 进行用户登录（此时认证消息包含在request里），登录完之后，重定向到self.get_next_url(user)。

![使用login_user进行登录](D:\2020_Sources\2020秋\实习\截图\2-22\使用login_user进行登录.png)

4.重定向到auto_login_url（此时好像是使用自定义的验证器）。

![](D:\2020_Sources\2020秋\实习\截图\2-22\重定向到auto_login_url.png)



- **login_user**

  1. 使用authenticator.authenticate对data进行验证（data表示request里的数据？）

  2. 如果验证失败，authenticator.authenticate返回None；

     如果验证成功，authenticator.authenticate将会返回用户字典（里面包含这个用户的一系列信息）

  3. 验证失败后将会显示失败信息；

     验证成功后，将会使用self.auth_to_user()将.authenticate()中的数据持久化到数据库，然后设置login_cookie,并显示成功信息，返回user。

- 重定向到**get_next_url**(user)

  1.如果设置了self.redirect_to_server,则重定向到用户对应的user.url。若spawner还没有active，则先重定向到/spawn/页面。
  如果没有设置self.redirect_to_server，默认重定向到/home/页面。

  ![get_next_url](D:\2020_Sources\2020秋\实习\截图\2-22\get_next_url.png)

  

  2.如果重定向到了/spawn/页面，将使用SpawnHandler处理请求。

  ![get_next_url_spawn](D:\2020_Sources\2020秋\实习\截图\2-22\get_next_url_spawn.png)

  

**POST**

1.收到post请求后，解析参数

2.然后使用login_user()进行用户身份验证

3.验证成功则重定向到self.get_next_url()

4.否则显示错误信息

![login_post](D:\2020_Sources\2020秋\实习\截图\2-22\login_post.png)





### 默认的用户验证器PAMAuthenticator()







### 官方视频笔记

#### notebook

![image-20210221133747649](C:\Users\hyp19\AppData\Roaming\Typora\typora-user-images\image-20210221133747649.png)

- 浏览器通过HTTP连接的方式发送WebSocket与NoteBook Server连接；

  NoteBook Server是一个tornado web server，可以spawn（生成）一些相互分离的kernels。NoteBook Server通过ZeroMQ与Kernel通信

- 通信流程

  - 当用户在浏览器的cell里面输入代码并运行时，这些信息将会通过**WebSocke**t发送给NoteBook Server
  - 然后NoteBook Server将会以**ZQM**信息的方式和kernel交互，将这些请求传送给kernel；

  -  kernel内部运算出结果之后，会将这些结果以**ZMQ**通信的方式传送给NoteBook Server
  - 然后NoteBook Server将这些信息再通过**WebSocket**传送给Browser。

- NoteBook Server及其所生成的Kernel被视作一个单独的application，一个多进程、单用户（multi-process  single-user）的application.

#### JupyterHub

![image-20210221135126552](C:\Users\hyp19\AppData\Roaming\Typora\typora-user-images\image-20210221135126552.png)

- 在jupyterhub中，NoteBook Server、Browser同上，但是增加了一个**Http-proxy**和一个hub。(最新的代码,看注册的地方)
- JupyterHub可以管理身份验证，而且是高度可配置的
- Jupyterhub按需为每一个用户生成single-user Server 用户登录时：

- - 用户发送请求给proxy，然后proxy将请求交给hub处理
  - 此时hub要求用户登录，默认使用PAM，也可以使用其他的自定义验证方式
  - 验证成功之后，spawner对象将会为该用户生成（？）、启动（start）其对应的server，然后**通知hub**（这里不是很清楚）**activity**,**jupytehub singleuser(添加了一些东西-excel表)**
  - 然后hub通知proxy，需要为这个用户对应的这个server添加一个路由
  - 重定向到/user/[name]
  - 接下来这个single user server就能够处理这个用户的请求了，比如进行文件修改、创建等。但每一次收到请求都要将cookie交给hub进行验证



### SpawnHandler里使用spawner生成single-user application

#### 流程:

1. SpawnHandler接收到post请求之后, 使用user.spawner[server_name]获取spawner

   ![3-post获取spawner](D:\2020_Sources\2020秋\实习\截图\2-22\3-post获取spawner.png)

2. 然后根据用户提交的选项, 使用._wrap_spawn_single_user()生成single-user app

   ![3-使用wrap_spawn_sinle_user](D:\2020_Sources\2020秋\实习\截图\2-22\3-使用wrap_spawn_sinle_user.png)

3. 设置login_cookie

4. 重定向到spawn-pending页面

![3-post-设置login cookie并重定向](D:\2020_Sources\2020秋\实习\截图\2-22\3-post-设置login cookie并重定向.png)

生成single-user app的具体过程

- 在._wrap_spawn_single_user()中,首先**清除spawner.__spawn_future(异步相关),**然后使用spawn_singler_user生成app

  ![3-.wrap-clean](D:\2020_Sources\2020秋\实习\截图\2-22\3-.wrap-clean.png)

  ![3-wrap使用spawn_singleuser](D:\2020_Sources\2020秋\实习\截图\2-22\3-wrap使用spawn_singleuser.png)

- spawn_single_user中,使用user.spawn(),启动user的spawner

  ![3-使用user.spawn](D:\2020_Sources\2020秋\实习\截图\2-22\3-使用user.spawn.png)

  

- user.spawn()里

  ![2-spawn](D:\2020_Sources\2020秋\实习\截图\2-22\2-spawn.png)

  1.  首先在db中添加待生成的server, 然后使用oauth_provider.add_client创建一个客户端,添加到db中(**哪些字段**)

     ![2-spawn-db](D:\2020_Sources\2020秋\实习\截图\2-22\2-spawn-db.png)

     ![2-spawn-client](D:\2020_Sources\2020秋\实习\截图\2-22\2-spawn-client.png)

     ![2-add-client](D:\2020_Sources\2020秋\实习\截图\2-22\2-add-client.png)

  2. 然后使用**authenticator.pre_spawn_start()(和spawner成对出现)**创建一个PAM session(**看一下其他的第三方spawner**)

     ![](D:\2020_Sources\2020秋\实习\截图\2-22\2-pre_spawn_start.png)

     ![2-open-PAMsession](D:\2020_Sources\2020秋\实习\截图\2-22\2-open-PAMsession.png)

  3. 设置named_server的profile

  4. ...

  5. 调用spawner.start()

     

     ![2-spawner.start](D:\2020_Sources\2020秋\实习\截图\2-22\2-spawner.start.png)

#### LocalProcessSpawner

- 用.start()实现创建一个singleuser app, 关键代码如下:

  ![1-start](D:\2020_Sources\2020秋\实习\截图\2-22\1-start.png)

![1-关键代码](D:\2020_Sources\2020秋\实习\截图\2-22\1-关键代码.png)

​		其中,Popen()创建并分配一个子进程, 并在这个进程中执行指定的进程.

![1-cmd](D:\2020_Sources\2020秋\实习\截图\2-22\1-cmd.png)





1. 
2. 