# TODO

- 源码结束掉

- [x] 检查当前用户是否为空(进入prepare看一下)
- [x] spawner如何维持active的状态（？这个问题没听清）
- [ ] 找到所有Http-proxy注册的地方
- [ ] **authenticator.pre_spawn_start()(和spawner成对出现)**创建一个PAM session(**看一下其他的第三方spawner**)
- [ ] oauth_provider.add_client创建一个客户端,添加到db中(**db中有哪些字段**，分别是做什么的)
- [ ] **通知hub**（这里不是很清楚）**activity**,**jupytehub singleuser(添加了一些东西-用excel表列出来)**
- [x] spawner的各个状态以及状态转换的条件和接口(流程)

- 可以开始看鹏程云脑的部分 下周要开始写代码了
- OKR填写





# OKR

- 鹏程云脑

  - 第二季度的版本(过程管理)

    1. ipynb git版本管理的插件实现

       jupyterlab git相关的方案,如何集成进来,现在的基本都是针对单个ipynb

       要针对单独的一个用户空间做一个整体的git 方案预研 给结论

    2. 换内核

       内核有版本了之后得上这个功能, 所以要先在本地装docker,run了之后能访问这个地址就行了

    3. http file manager是以文件配置的形式做的, 但是在notebook里面的代码是直接改的,所以要将它做成插件

       现在还是整体打包,不便于升级的适配

  - 越快越好

- jupyterhub弄成一个技术分享的博客文章(结果管理)
  - 比较重点的地方说清楚
  - 3.31号之前要提交(其实这周尽可能要有结果)
  - 源码分析:认证,,自定义自己写一下,不要再光看了.
  - 细节部分:遇到问题, 出现bug之后才能知道重点在哪,细节要注意哪里.



- 每周过来一天,至少.确定时间.按自己的时间就好.

# 毕设相关

- jupyter

- 后续做**毕设** 写文章,发文章,考虑一下如下方向

  - 工程方面:ai平台(jupyter相关的,插件/用户)

  - 机器学习训练相关的东西,框架

  - 不建议算法,但是可以做一下autoML,参数选择/特征选择,先得看懂一个框架是由那几个部分组成的

  - 数据沙箱产品的一些规划

    - 数据可用不可见
    - 数据不动 代码动

    

# 具体执行

- [ ] 整理出上次提出的几点问题

  - [x] 检查当前用户是否为空(进入prepare看一下)

  - [x] 如何维持active的状态

  - [ ] Http-proxy注册的地方

  - [ ] **authenticator.pre_spawn_start()(和spawner成对出现)**创建一个PAM session(**看一下其他的第三方spawner**)

    pre_spawn_hook()函数实现在spanwer 启动之前做一些必要的bootstrapping工作，例如创建用户的目录、加载initial content。这是可以自定义的。

  - [ ] oauth_provider.add_client创建一个客户端,添加到db中(**哪些字段**)

  - [ ] **通知hub**（这里不是很清楚）**activity**,**jupytehub singleuser(添加了一些东西-excel表)**

  - [x] spawner状态转换的条件和接口(流程)

    

- [ ] 调研jupyterlab的git

  

- [ ] 调研jupyter notebook的file manager

  

- [ ] 学习k8s相关知识

  
  
- [ ] 其他

  - [ ] jupyterlab-hub 了解一下
  - [ ] jupyterhub中的orm了解一下，数据库
  - [ ] 继续调研状态！！！
  
  

# 文档输出

## jupyter整体架构相关

### **Jupyter扩展方式**

- 模块化、扩展性

- 上图中的JupyterLab、Notebook Server、IPython、JupyterHub都是可扩展的。

**JupyterLab扩展（labextension）**

JupyterLab是Jupyter的前端项目，它的一大特点就是便于扩展。通过开发JupyterLab扩展，可以为前端界面增加新功能，例如新的文件类型打开/编辑支持、Notebook工具栏增加新的按钮、菜单栏增加新的菜单项等等。

JupyterLab扩展通常采用TypeScript开发，可参考[开发文档](https://jupyterlab.readthedocs.io/en/stable/developer/extension_dev.html)。

**Notebook Server扩展（serverextension）**

Notebook Server是用Python写的一个基于[Tornado](https://www.tornadoweb.org/en/stable/)的Web服务。

通过Notebook Server扩展，可以为这个Web服务增加新的Handler。增加新的Handler通常有两种用途：

1. 为JupyterLab扩展提供对应的后端接口，用于响应一些需要由服务端处理的事件。例如调度任务的注册需要通过JupyterLab扩展发起请求，由Notebook Server扩展执行。
2. 提供一个前端界面以及对应的后端处理服务。例如jupyter-rsession-proxy，用于在JupyterHub中使用RStudio。

Notebook Server扩展开发文档可参考[开发文档](https://jupyter-notebook.readthedocs.io/en/stable/extending/handlers.html)。

**Jupyter Kernels**

Jupyter用于执行代码的模块叫Kernel，除了默认的ipykernel以外，还可以有其他的Kernel用于支持其他编程语言。例如支持Scala语言的[almond](https://almond.sh/)、支持R语言的[irkernel](https://irkernel.github.io/)，更多详见[语言支持列表](https://github.com/jupyter/jupyter/wiki/Jupyter-kernels)。

**IPython Magics**

IPython Magics就是那些%、%%开头的命令。常见的Magics有 %matplotlib inline，设置Notebook中调用matplotlib的绘图函数时，直接展示图表在Notebook中。执行Magics时，事实上是调用了该Magics定义的一个函数。对于Line Magics（一个%），传入函数的是当前行的代码；对于Cell Magics（两个%），传入的是整个Cell的内容。定义一个新的IPython Magics仅需定义一个函数，这个函数的入参有两个，一个是当前会话实例，可以用来遍历当前会话的所有变量，可以为当前会话增加新的变量；另一个是用户输入，对于Line Magics是当前行，对于Cell Magcis是当前Cell。

IPython Magics在简化代码方面非常有效，我们开发了%%spark、%%sql用于创建Spark会话以及SQL查询。另外很多第三方的Magics可以用来提高我们的开发效率，例如在开发Word2Vec变种时，使用%%cython来进行Cython和Python混合编程，省去编译加载模块的工作。

IPython Magics开发文档可参考：

https://ipython.readthedocs.io/en/stable/config/custommagics.html。

**IPython Widgets（ipywidgets）**

IPython Widgets是一种基于Jupyter Notebook和IPython的可交互控件。与普通可视化不同的是，在控件上的交互会触发和Python的通信并执行相应的代码，Python上相应的动作也会触发界面实时变化。

IPython Widgets在提供工具类型的功能增强上非常有用，基于它，我们实现了一个线上排序服务的调试和复现工具，用于展示排序结果以及指定房源在排序过程中的各种特征以及中间变量的值。IPython Widgets的开发可以通过组合现有的Widgets实现，也可以完全自定义一个，IPython Widgets开发文档可参考：

[https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20Custom.html](https://ipywidgets.readthedocs.io/en/stable/examples/Widget Custom.html)。

**扩展JupyterHub**

**Authenticators**

JupyterHub是一个多用户系统，登录模块可替换，通过实现新的Authenticator类并在配置文件中指定即可。通过这个扩展点，我们实现了使用内部SSO系统登录JupyterHub。Authenticator开发文档可参考：

https://jupyterhub.readthedocs.io/en/stable/reference/authenticators.html。

**Spawners**

当用户登录时，JupyterHub需要为用户启动一个用户专用Notebook Server。启动这个Notebook Server有多种方式：本机新的Notebook Server进程、本机启动Docker实例、K8s系统中启动新的Pod、YARN中启动新的实例等等。每一种启动方式都对应一个Spawner，官方提供了多种Spawner的实现，这些实现本身是可配置的。如果不符合需求，也可以自己开发全新的Spawner。由于我们需要实现Spark接入，对K8s的Pod有新的要求，所以基于KubeSpawner定制了一个Spawner来解决Spark连接集群的网络问题。Spawner开发文档可参考：

https://jupyterhub.readthedocs.io/en/stable/reference/spawners.html。



## Jupyter历史见其他文档



## 认证过程补充

### 认证和授权的区别：

- Authentication：你是谁，关于ID、密码等
- Authorization：你能做什么，关于admin等
  

### Cookie

- 保存在客户端，存放的是关于用户的信息

- 应用案例

  - 页面1和页面2是同一个域名，但是只在页面1登录了。希望在进入页面2的时候服务器能直接知道我是哪一个用户，而不需要重新登录。于是可以在这个域名下设置一个cookie，当用户在页面1进行了登录之后，服务器就会为该用户在这个域名下设置一个cookie，保存到客户端，于是用户在访问页面2的时候，会把cookie也发送过去，客户端由cookie可以知道这是那个用户，就不用再进行登录了。
  - 保存已经登陆过的用户信息，可以自动填写一些基本信息
  - 保存session或者token，用来发送给服务器，以便于让后端知道用户当前的状态（HTTP是无状态的）
  - 用来记录、分析用户行为，比如在某个页面查看过哪些内容，以便于个性化推荐

- Cookie的设置和使用

  

### Session

- 保存在服务器端，客户端存储的只有sessionID，写在cookie文件里。session认证就是把user的信息存储到session里面。(其实两端都需要存储)
- 应用案例







### Token

- 令牌，最简单的就是，uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。如果是OAuth Token这种机制，就是提供认证（让服务器知道你是谁）和授权（使App拥有访问某用户信息的权利）。

- 应用案例
  - 当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会**生成一个 token 值**，这个值，会在**服务器保存token**值(保存在数据库中)，再将这个token值**返回给客户端**.

    客户端拿到 token 值之后,进行**本地保存**。（SP存储是大家能够比较支持和易于理解操作的存储）

    当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值**附带到参数**中发送给服务器.

    服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做**对比**: 如果两个 token 值相同， 说明用户登录成功过,当前用户处于登录状态.如果没有这个 token 值, 则说明没有登录成功.如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录.

  

  

  

### Cookie验证和Token验证的区别

- Cookie验证：利用cookie存储sessionID进行验证，或者利用cookie存储Token进行验证。

  - 有状态，验证记录或者会话需要一直在server（session）或client（cookie）端保持。server需要保持对数据库活动会话的追踪。也就不便于应用的扩展。

- Token验证：Token存储在Authorization Header中进行验证。

  - 无状态，服务器端不需要保留用户的认证信息或者会话信息。基于token认证机制的应用不需要考虑用户在哪一台服务器登录了，有利于应用的扩展。

    每个请求都带上server要求验证的token，token放在Authorization header中发送过去。也可以在其他字段发送，例如post body，query parameter。

    server端不需要保持对token的记录，它只需要在登录成功后生成或者sign token，token发送过来之后对其进行验证即可。如果使用了第三方服务，则是由第三方进行token的签发，而server只需要验证token的有效性即可。

    可以把token放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：` Authorization: Bearer Token`。

  ![image-20210224182155739](C:\Users\hyp19\AppData\Roaming\Typora\typora-user-images\image-20210224182155739.png)

  （来自csdn，需要进一步验证）



### 代码解析

![2-get_current_user()](D:\2020_Sources\2020秋\实习\截图\2-27\2-27\2-get_current_user().png)

- **self.get_current_user_token**:(首先使用Token验证方式，查看是否在请求中含有一个JWT(?大概是通过这个东西？)，获取Authorization中的Token, 然后在数据库中寻找是否存在对应的正确的token。再根据orm_token.user到数据库中寻找user。验证成功则返回用户，否则（数据库中找不到正确的token）返回none。（还需要详细看一下，可能不准确。）

  ![2-get_current_user_token()](D:\2020_Sources\2020秋\实习\截图\2-27\2-27\2-get_current_user_token().png)

- **self.get_current_user_cookie**:使用self.hub.cookie_name()获取cookie_name,然后再数据库里寻找相应的用户。如果成功则返回用户，否则返回None。



![2-get_current_user_cookie()](D:\2020_Sources\2020秋\实习\截图\2-27\2-27\2-get_current_user_cookie().png)



- ![2-_user_for_cookie](D:\2020_Sources\2020秋\实习\截图\2-27\2-27\2-_user_for_cookie.png)登录以及后续处理流程：

  当访问/hub/时，proxy将·会把请求转发给hub处理，hub首先会检查用户是否登录，如果没有登录，则先重定向到登录页面，登录成功之后，若配置中redirect_to_server为真，则重定向到/hub/spawn/页面，此时就由spawner来处理这个流程。



## Jupyterhub URL 处理行为



### /   或者   /xxx

- /->重定向到/hub/
- /xxx->重定向到/hub/xxx



### /hub

![hub URL](D:\2021\实习\jupyter学习\思维导图\hub URL.png)

似乎还有一个地方设置了自定义跳转的next_url，具体还要看代码。

### /hub/home

这个页面提供给用户，用来进行多个server的管理（运行/终止运行）

![image-20210227131743228](C:\Users\hyp19\AppData\Roaming\Typora\typora-user-images\image-20210227131743228.png)

### hub/login

![hub Login URL](D:\2021\实习\jupyter学习\思维导图\hub Login URL.png)

### hub/logout

清除browser中的cookie。

但不会默认shutdown这个用户的server，因为server可能在其他的browser中被使用。



### /hub/:username[:servername]

这个请求将会给对应用户的对应server进行处理。

如果这个server不是running的状态，那么会重定向到hub/user/...





### /hub/user/:username[/:servername]

这个 URL 表示对一个未运行的用户服务器的请求。根据服务器的不同状态，处理这个 URL:

1. 服务器没有被激活，则重定向至/hub/spawn/: username/: servername 的链接。因为对未运行的服务器发出了请求，此时HTTP 状态将为503。
2. 服务器就绪（ready），假定代理尚未注册该路由。重定向至/user/: username/: servername/... 执行一些检查并延时。如果出现了问题，可能会**导致重定向循环。**
3. 服务器正在（启动中），但还没就绪（ready）。重定向到/hub/spawn-pending/: username/: servername，展示进度，等待服务器准备就绪。

（注意，这个页面不会自动生成server，除非用户自己选择了某些选项。）

### /user/:username[/:servername]/api/...

这些请求可以看成来自连接到已经stop了的服务器的application。这些操作会失败，http状态为503，会发送一条说明如何spawn一个服务的JSON 消息。

这便于像 JupyterLab 等应用程序连接到已经stop的服务器。

### /user-redirect/...

这将会重定向到用户自己服务器上的...url和路径。例如： `/user-redirect/notebooks/Index.ipynb` 将会把 用户`hortense` 重定向到 `/user/hortense/notebooks/Index.ipynb`

### /hub/spawn[/:username[/:servername]]

这将会生成指定用户，指定名称的服务器，默认为当前用户和默认服务器。

如果设置了 Spawner.optins_form,那么首先会重定向到一个带有spawner选项表单的页面，以便于用户自定义。

![image-20210225111158436](C:\Users\hyp19\AppData\Roaming\Typora\typora-user-images\image-20210225111158436.png)

### /hub/spawn-pending[/:username[/:servername]]

这个页面将会呈现生成用户server的进度视图，如下图。

server 状态为ready之后，将会重定向到/user/: username/: servername/... ，也就是用户的server的页面。如果server生成失败，那么这个页面将会显示一个到/hub/spawn/... 的链接供用户点击。如果对应的server本身就在运行，那么直接重定向到对应server的页面(/user/: username/: servername/...)。

![image-20210225111249399](C:\Users\hyp19\AppData\Roaming\Typora\typora-user-images\image-20210225111249399.png)

### /hub/token

在	这个页面上，用户可以管理他们的 JupyterHub API 令牌。它们可以撤销访问权限，并请求针对 JupyterHub REST API 编写脚本的新标记。

**这个还要具体看一下代码。**

### /hub/admin

管理员可以从这个页面执行各种管理操作:

1. 添加/删除用户

2. 授予管理员特权

3. 启动或者终止 某用户的 servers

4. 关闭 JupyterHub

   



## 零散知识积累

### JWT

- JSON web token，是为了在网络应用环境间传递声明而执行的一种**基于JSON**的开放标准（[(RFC 7519](https://link.jianshu.com?t=https://tools.ietf.org/html/rfc7519)).该token被设计为紧凑且安全的，特别适用于**分布式站点**的单点登录（SSO）场景。

  JWT的声明一般被用来在**身份提供者**和**服务提供者**间传递**被认证的用户身份信息**，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

  JWT一般在请求头里加入Authorization，并加上Bearer标注。

- 构成：head+payload+signature。

  - 将这三段信息文本用`.`链接一起就构成了Jwt字符串。

    e.g.

    - 编码的JWT

    ```
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    ```

    - 将以上JWT解码后如下

    ```
    #header:
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    #payload
    {
      "sub": "1234567890",
      "name": "John Doe",
      "iat": 1516239022
    }
    #signature
    HMACSHA256(
      base64UrlEncode(header) + "." +
      base64UrlEncode(payload),
      your-256-bit-secret
    
    )
    ```

    

  - 其中，在isgniture中的secret是保存在服务端用来进行jwt的签发和jwt的验证，这是服务端的私钥，不应该被客户知道（否则客户就可以自己签发了）。

  对于其构成的详细介绍，查阅[参考博客](https://www.jianshu.com/p/576dbf44b2ae)

  

  

- 应用：（Oauth2的jwt流程）

  ![img](https://upload-images.jianshu.io/upload_images/1821058-2e28fe6c997a60c9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

- 特点

  因为json的通用性，所以JWT是可以进行跨语言支持的

  有payload部分，JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息

  jwt的构成非常简单，便于传输

  易于应用的扩展

### 分布式的sso单点登录

- 概念：在A系统中登录了之后，希望在B系统中不需要登录了。





## Single-user Server相关

- single-user server实际上就是jupyter notebook 的一个instance。

- server的几个状态：
- 